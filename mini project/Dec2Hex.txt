#include <iregdef.h>
.data
buffer: .space 20 #*change #maximum 20 char
prompt: .asciiz "Enter the decimal number to convert: "
ans: .asciiz "\nHexadecimal equivalent: "
result: .space 8 #result is saved here
.text
.globl main

main:
	la a0, prompt #load string `promt
	jal printf #print
	nop
    la a0,buffer
    add a1,zero,20
	jal InputDec #InputDec string into buffer
	nop
	la a0,buffer #load buffer into a0
	jal atoi #parsing string to integer
	nop
	add s0,v0,zero #s0 = integer parsed
	

	la a0, ans #load string `ans
	jal printf #printf
	nop
	add a0,s0,zero #load s0
    la a1,result
    add a2,zero,8
	jal Dec2Hex #call Dec2Hex to convert into hex
	nop
	la a0,result #load result array 8 chars coressponding to 8 byte of this hexadecimal
	jal printf #printf hex number
	nop

#input decimal string
#a0 = begining address of string
#a1 = maximum length of string
#v0 = length of string
.ent InputDec	
InputDec:
	move s1,ra #store restore address
	add s0,a1,zero #load maximum size of `buffer
    add t0,a0,zero #load begining address of string
	li t1,0 #t0 as i
	cont_InputDec:
		jal getchar #get 1 char
		nop
		li v1,'\n'
		sub t2,v0,v1
		beq t2,zero,finish_InputDec #if getchar() == '\n' --> finish InputDec
		nop
		ble v0,47,cont_InputDec #determine what is InputDeced
		nop
		bge v0,58,cont_InputDec #determine what is InputDeced
		nop
		add t2,v0,zero
		sb t2,0(t0) #save to buffer
		add a0,t2,zero
		jal putchar
		nop
		addi t0,t0,1 #i++
        addi t1,t1,1
		slt t2,s0,t1
		beq t2,zero,cont_InputDec #if i < 20 continue getchar
		nop
	finish_InputDec:
		sb zero,0(t0) #ending zero
        add v0,t0,zero
		move ra,s1
		jr ra
		nop
.end InputDec


#a0 - string
#v0 = integer
.ent atoi
atoi:
	or      v0, zero, zero   # num = 0
    	or      t1, zero, zero   # isNegative = false
    	lb      t0, 0(a0)
    	bne     t0, '+', .isp_atoi      # consume a positive symbol
    	nop
    	addi    a0, a0, 1
.isp_atoi:
    	lb      t0, 0(a0)
    	bne     t0, '-', .num_atoi
    	nop
    	addi    t1, zero, 1       # isNegative = true
    	addi    a0, a0, 1
.num_atoi:
    	lb      t0, 0(a0)
    	slti    t2, t0, 58        # *str <= '9'
    	slti    t3, t0, '0'       # *str < '0'
    	beq     t2, zero, .done_atoi
    	nop
    	bne     t3, zero, .done_atoi
    	nop
    	sll     t2, v0, 1
    	sll     v0, v0, 3
    	add     v0, v0, t2       # num *= 10, using: num = (num << 3) + (num << 1)
    	addi    t0, t0, -48
    	add     v0, v0, t0       # num += (*str - '0')
    	addi    a0, a0, 1         # ++num
    	j   .num_atoi
    	nop
.done_atoi:
    	beq     t1, zero, .out_atoi    # if (isNegative) num = -num
    	nop
    	sub     v0, zero, v0
.out_atoi:
    	jr      ra         # return
	nop
.end atoi

#a0 = decimal number
#a1 = begin address of hex string
#a2 = maximum length of hex string
#v0 = 1 --> succesful
.ent Dec2Hex
Dec2Hex:
	add t0,a2,zero		        # counter
    add t3,a1,zero #begining address of hex string
	#la t3, result		# where answer will be stored
	move t2, a0
	
	Loop_t0_Dec2Hex:

		beqz t0, Exit_Dec2Hex		# branch to exit if counter is equal to zero
		nop
		rol t2, t2, 4		# rotate 4 bits to the left
		and t4, t2, 0x0000000f	        # mask with 0..001111
		ble t4, 9, Sum_Dec2Hex		# if less than or equal to nine, branch to sum
		nop
		addi t4, t4, 55        # if greater than nine, add 55

		b End_Dec2Hex
		nop
	Sum_Dec2Hex:
		addi t4, t4, 48	# add 48 to result
	End_Dec2Hex:

		sb t4, 0(t3)		# store hex digit into result
		addi t3, t3, 1		# increment address counter
		addi t0, t0, -1		# decrement loop counter

		j Loop_t0_Dec2Hex
		nop
	Exit_Dec2Hex:
		li v0,1
		jr ra
		nop
.end Dec2Hex
#The End
