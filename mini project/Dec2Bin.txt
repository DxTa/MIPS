
#include <iregdef.h>
.data
buffer: .space 20 #*change #maximum 20 char
prompt: .asciiz "Enter the decimal number to convert: "
ans: .asciiz "\nHexadecimal equivalent: "
result: .space 32 #result is saved here
.text
.globl main

main:
	la a0, prompt #load string `promt
	jal printf #print
	nop
    la a0,buffer
    add a1,zero,20
	jal InputDec #InputDec string into buffer
	nop
	la a0,buffer #load buffer into a0
	jal atoi #parsing string to integer
	nop
	add s0,v0,zero #s0 = integer parsed
	

	la a0, ans #load string `ans
	jal printf #printf
	nop
	add a0,s0,zero #load s0
    la a1,result
    add a2,zero,32
	jal Dec2Bin #call Dec2Bin to convert into hex
	nop
	la a0,result #load result array 8 chars coressponding to 8 byte of this hexadecimal
	jal printf #printf hex number
	nop

#input decimal string
#a0 = begining address of string
#a1 = maximum length of string
#v0 = length of string
.ent InputDec	
InputDec:
	move s1,ra #store restore address
	add s0,a1,zero #load maximum size of `buffer
    add t0,a0,zero #load begining address of string
	li t1,0 #t0 as i
	cont_InputDec:
		jal getchar #get 1 char
		nop
		li v1,'\n'
		sub t2,v0,v1
		beq t2,zero,finish_InputDec #if getchar() == '\n' --> finish InputDec
		nop
		ble v0,47,cont_InputDec #determine what is InputDeced
		nop
		bge v0,58,cont_InputDec #determine what is InputDeced
		nop
		add t2,v0,zero
		sb t2,0(t0) #save to buffer
		add a0,t2,zero
		jal putchar
		nop
		addi t0,t0,1 #i++
        addi t1,t1,1
		slt t2,s0,t1
		beq t2,zero,cont_InputDec #if i < 20 continue getchar
		nop
	finish_InputDec:
		sb zero,0(t0) #ending zero
        add v0,t0,zero
		move ra,s1
		jr ra
		nop
.end InputDec


#a0 - string
#v0 = integer
.ent atoi
atoi:
	or      v0, zero, zero   # num = 0
    	or      t1, zero, zero   # isNegative = false
    	lb      t0, 0(a0)
    	bne     t0, '+', .isp_atoi      # consume a positive symbol
    	nop
    	addi    a0, a0, 1
.isp_atoi:
    	lb      t0, 0(a0)
    	bne     t0, '-', .num_atoi
    	nop
    	addi    t1, zero, 1       # isNegative = true
    	addi    a0, a0, 1
.num_atoi:
    	lb      t0, 0(a0)
    	slti    t2, t0, 58        # *str <= '9'
    	slti    t3, t0, '0'       # *str < '0'
    	beq     t2, zero, .done_atoi
    	nop
    	bne     t3, zero, .done_atoi
    	nop
    	sll     t2, v0, 1
    	sll     v0, v0, 3
    	add     v0, v0, t2       # num *= 10, using: num = (num << 3) + (num << 1)
    	addi    t0, t0, -48
    	add     v0, v0, t0       # num += (*str - '0')
    	addi    a0, a0, 1         # ++num
    	j   .num_atoi
    	nop
.done_atoi:
    	beq     t1, zero, .out_atoi    # if (isNegative) num = -num
    	nop
    	sub     v0, zero, v0
.out_atoi:
    	jr      ra         # return
	nop
.end atoi

#a0 = decimal number
#a1 = begin address of hex string
#a2 = maximum length of hex string
#v0 = 1 --> succesful
.ent Dec2Bin
Dec2Bin:
	add t0,a2,zero		        # counter
    add t3,a1,zero #begining address of hex string
	#la t3, result		# where answer will be stored
	move t2, a0 #t2 = decimal number
	li t6,48 #char 0
	li t7,49 #char 1
	li s0,1 #s0 to store 0x1
	Loop_t0_Dec2Bin:

		beqz t0, Exit_Dec2Bin		# branch to exit if counter is equal to zero
		nop
		addi t0,t0,-1
		sll t4, s0, t0		# shift left t0 -1 bits to the left
		and t4, t4, t2	        # mask with 0..001111
		beq t4,zero,add_0_Dec2Bin
		nop
        j add_1_Dec2Bin
        nop
        add_0_Dec2Bin:
            sb t6,0(t3)
            addi t3,t3,1
            j Loop_t0_Dec2Bin
            nop
        add_1_Dec2Bin:
    		sb t7,0(t3)
            addi t3,t3,1
            j Loop_t0_Dec2Bin
            nop        

	Exit_Dec2Bin:
		sb zero,0(t3) #end with zero
		li v0,1
		jr ra
		nop
.end Dec2Bin
#The End
