#include <iregdef.h>
.data
buffer: .space 20 #*change //maximum 20 char
prompt: .asciiz "Enter the decimal number to convert: "
ans: .asciiz "\nHexadecimal equivalent: "
result: .space 8 //result is saved here
.text
.globl main

main:
	la a0, prompt //load string `promt'
	jal printf //print
	nop
	jal Input //input string into buffer
	nop
	la a0,buffer //load buffer into a0
	jal atoi //parsing string to integer
	nop
	add s0,v0,zero //s0 = integer parsed
	

	la a0, ans //load string `ans'
	jal printf //printf
	nop
	add a0,s0,zero //load s0
	jal Dec2Hex //call Dec2Hex to convert into hex
	nop
	la a0,result //load result array 8 chars coressponding to 8 byte of this hexadecimal
	jal printf //printf hex number
	nop

.ent Input	
Input:
	move s1,ra //store restore address
	li s0,20 //load maximum size of `buffer'
	li t0,0 //t0 as i
	cont_input:
		jal getchar //get 1 char
		nop
		li v1,'\n'
		sub t1,v0,v1
		beq t1,zero,finish_input_dec //if getchar() == '\n' --> finish input
		nop
		ble v0,48,cont_input //determine what is inputed
		nop
		bge v0,57,cont_input //determine what is inputed
		nop
		add t1,v0,zero
		sb t1,buffer(t0) //save to buffer
		add a0,t1,zero
		jal putchar
		nop
		addi t0,t0,1 //i++
		slt t1,s0,t0
		beq t1,zero,cont_input //if i < 20 continue getchar
		nop
	finish_input_dec:
		sb zero,buffer(t0) #ending zero
		move ra,s1
		jr ra
		nop
.end Input


#a0 - string
.ent atoi
atoi:
	or      v0, zero, zero   # num = 0
    	or      t1, zero, zero   # isNegative = false
    	lb      t0, 0(a0)
    	bne     t0, '+', .isp_atoi      # consume a positive symbol
    	nop
    	addi    a0, a0, 1
.isp_atoi:
    	lb      t0, 0(a0)
    	bne     t0, '-', .num_atoi
    	nop
    	addi    t1, zero, 1       # isNegative = true
    	addi    a0, a0, 1
.num_atoi:
    	lb      t0, 0(a0)
    	slti    t2, t0, 58        # *str <= '9'
    	slti    t3, t0, '0'       # *str < '0'
    	beq     t2, zero, .done_atoi
    	nop
    	bne     t3, zero, .done_atoi
    	nop
    	sll     t2, v0, 1
    	sll     v0, v0, 3
    	add     v0, v0, t2       # num *= 10, using: num = (num << 3) + (num << 1)
    	addi    t0, t0, -48
    	add     v0, v0, t0       # num += (*str - '0')
    	addi    a0, a0, 1         # ++num
    	j   .num_atoi
    	nop
.done_atoi:
    	beq     t1, zero, .out_atoi    # if (isNegative) num = -num
    	nop
    	sub     v0, zero, v0
.out_atoi:
    	jr      ra         # return
	nop
.end atoi
	
.ent Dec2Hex
Dec2Hex:
	li t0, 8		        # counter
	la t3, result		# where answer will be stored
	move t2, a0
	
	Loop_t0:

		beqz t0, Exit		# branch to exit if counter is equal to zero
		nop
		rol t2, t2, 4		# rotate 4 bits to the left
		and t4, t2, 0x0000000f	        # mask with 0..001111
		ble t4, 9, Sum		# if less than or equal to nine, branch to sum
		nop
		addi t4, t4, 55        # if greater than nine, add 55

		b End
		nop
	Sum:
		addi t4, t4, 48	# add 48 to result
	End:

		sb t4, 0(t3)		# store hex digit into result
		addi t3, t3, 1		# increment address counter
		addi t0, t0, -1		# decrement loop counter

		j Loop_t0
		nop
	Exit:
		li v0,1
		jr ra
		nop
.end Dec2Hex

